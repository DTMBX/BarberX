# Forensic Guarantees — Evident Discovery Suite

This document enumerates the five forensic-grade guarantees provided by the BWC
backend stack and describes how to independently verify each one.

---

## 1. Evidence Immutability (WORM-like Object Storage)

**Guarantee:** Once uploaded to MinIO, evidence objects cannot be deleted or
overwritten. A deny-delete bucket policy blocks `s3:DeleteObject` and
`s3:DeleteObjectVersion` for all principals.

**Verification:**

```bash
# Attempt to delete an object — should fail with AccessDenied
aws --endpoint-url http://localhost:9000 \
    s3 rm s3://evidence/originals/CASE_ID/EVIDENCE_ID/file.txt
# Expected: delete failed: ... An error occurred (AccessDenied)
```

**Implementation:**

- `app/services/s3.py` → `_apply_immutable_policy()`
- Controlled by `S3_IMMUTABLE_POLICY=true` (default)

---

## 2. Object Key Naming Scheme

**Guarantee:** Every evidence object follows a strict canonical key pattern:

```
originals/<case_id>/<evidence_id>/<sanitised_filename>
```

Filenames are sanitised on ingestion — path separators, shell metacharacters,
and non-word characters (outside `[\w\-. ]`) are rejected with HTTP 422.

**Verification:**

```bash
# Upload with a path-traversal filename — should fail
curl -sf -X POST http://localhost:8000/evidence/init \
  -H "Content-Type: application/json" \
  -d '{"case_id":"...","filename":"../../etc/passwd","content_type":"text/plain","size_bytes":1}'
# Expected: 422 — "Filename contains disallowed characters."
```

**Implementation:**

- `app/api/routes/evidence.py` → `_SAFE_FILENAME_RE` + `evidence_init()`

---

## 3. Duplicate Evidence Prevention

**Guarantee:** Within a single case, no two finalised evidence files may share
the same SHA-256 digest. A partial unique index
`(case_id, sha256) WHERE sha256 IS NOT NULL` enforces this at the database
level. The API also performs a pre-check and returns HTTP 409 before the
constraint is hit.

**Verification:**

```bash
# Upload the same file twice to the same case
# First upload → 200 + SHA-256
# Second upload (same bytes) → POST /evidence/complete returns:
#   409 — "Duplicate evidence: SHA-256 ... already exists in this case."
```

**Implementation:**

- `alembic/versions/0002_forensic_hardening.py` — partial unique index
- `app/api/routes/evidence.py` → `evidence_complete()` duplicate check
- `app/models/evidence_file.py` → `__table_args__` Index

---

## 4. Manifest HMAC Signing

**Guarantee:** Every exported manifest includes an HMAC-SHA256 signature
computed over the canonical JSON payload using a server-side secret key
(`MANIFEST_HMAC_KEY`). This provides cryptographic proof that a manifest was
generated by the Evident system and has not been altered.

**Verification:**

```bash
# Export manifest
MANIFEST=$(curl -sf http://localhost:8000/cases/CASE_ID/export/manifest)

# Submit to verification endpoint
echo "$MANIFEST" | jq -c '{
  manifest_sha256: .manifest_sha256,
  manifest_hmac:   .manifest_hmac,
  case:            .case,
  evidence:        .evidence,
  audit:           .audit
}' | curl -sf -X POST http://localhost:8000/verify/manifest \
       -H "Content-Type: application/json" -d @-

# Expected:
# {"sha256_valid":true,"hmac_valid":true,
#  "detail":"Manifest integrity verified: SHA-256 and HMAC both valid."}
```

**Implementation:**

- `app/services/hashing.py` → `hmac_sha256()`, `verify_hmac_sha256()`
- `app/api/routes/manifest.py` — HMAC added to export
- `app/api/routes/verify.py` → `POST /verify/manifest`

---

## 5. Audit Replay Verification

**Guarantee:** An independent audit-replay endpoint re-derives the full
evidentiary chain from raw storage. For every finalised evidence file it:

1. Re-downloads the object from MinIO.
2. Recomputes its SHA-256 digest.
3. Compares it against the stored digest.
4. Confirms a matching `evidence.complete` audit event exists.
5. Verifies the audit trail is monotonically ordered by timestamp.

**Verification:**

```bash
curl -sf http://localhost:8000/verify/cases/CASE_ID/audit-replay | jq .

# Expected (clean case):
# {
#   "ok": true,
#   "events_checked": 3,
#   "evidence_checked": 1,
#   "sha256_mismatches": [],
#   "detail": "Audit replay PASSED — 1 evidence files verified, ..."
# }
```

**Implementation:**

- `app/api/routes/verify.py` → `GET /verify/cases/{case_id}/audit-replay`

---

## Running the Full Smoke Test

The smoke script validates all five guarantees in a single pass:

```bash
BWC_API_BASE=http://localhost:8000 bash bwc/scripts/smoke.sh
```

Expected output (all checks pass):

```
▸ Health check
  ✓ GET /health
▸ Create case
  ✓ POST /cases → <uuid>
▸ Init evidence upload
  ✓ POST /evidence/init → <uuid>
▸ Upload file to MinIO
  ✓ PUT presigned URL (HTTP 200)
▸ Complete evidence
  ✓ SHA-256 match: <digest>
▸ Export manifest
  ✓ Manifest SHA-256 match: <digest>
  ✓ Manifest HMAC present: <prefix>…
▸ Verify manifest (POST /verify/manifest)
  ✓ Manifest SHA-256 verified by server
  ✓ Manifest HMAC verified by server
▸ Audit replay (GET /verify/cases/<uuid>/audit-replay)
  ✓ Audit replay PASSED (1 evidence, 3 events)

══════ PASS ══════
```
